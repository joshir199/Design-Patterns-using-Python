# Design-Patterns-using-Python
Explaining all design patterns and their importance using Python code examples

-------------------------------------------------------------------------------
| Design Pattern        |       Description                                |
-------------------------------------------------------------------------------
| Creational Patterns   | Patterns focused on object creation.             |
-------------------------------------------------------------------------------
 1. Singleton           :    Ensures a class has only one instance.            
 2. Factory Method      :    Creates objects through an interface.            
 3. Abstract Factory    :    Creates families of related objects.             
 4. Builder             :    Separates complex object construction.           
 5. Prototype           :    Creates new objects by copying an existing one.

-------------------------------------------------------------------------------
| Structural Patterns   | Patterns focused on composition of classes/objects|
-------------------------------------------------------------------------------
 1. Adapter           :    Allows incompatible interfaces to work together. 
 2. Bridge            :    Decouples abstraction from implementation.      
 3. Composite         :    Treats individual objects and compositions alike.
 4. Decorator         :    Adds behavior to objects dynamically.            
 5. Facade            :    Provides a unified interface for a subsystem.    
 6. Flyweight         :    Shares objects to reduce memory usage.           
 7. Proxy             :    Controls access to an object.
    
-------------------------------------------------------------------------------
| Behavioral Patterns   | Patterns focused on communication between objects|
-------------------------------------------------------------------------------
 1. Chain of Respons. :    Passes requests along a chain of handlers.       
 2. Command           :    Turns a request into a stand-alone object.       
 3. Interpreter       :    Provides a language for interpreting input.      
 4. Iterator          :    Provides a way to access elements of an object. 
 5. Mediator          :    Reduces direct communication between objects.   
 6. Memento           :    Captures an object's internal state.             
 7. Observer          :    Notifies observers of state changes.            
 8. State             :    Alters an object's behavior as its state changes
 9. Strategy          :    Defines a family of interchangeable algorithms.
10. Template Method   :    Defines the structure of an algorithm.          
11. Visitor           :    Separates algorithm from object structure.
    
---------------------------------------------------------------------------
